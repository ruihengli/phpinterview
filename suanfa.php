<?php
echo "<PRE>";

//(315)最大子序列和（4种方式）
//序列：-2 11 -4 13 -5 -2，则最大子序列和为20。
//序列：-6 2 4 -7 5 3 2 -1 6 -9 10 -2，则最大子序列和为16。
//方法四、找规律算法  O(N)
function findMax4($data){
	$max_value = 0;
	$thisSum = 0;
	$data_len = count($data);
	$start = 0;
	$end = 0;
	for($i=0;$i<$data_len;$i++){
		$thisSum += $data[$i];
		if($thisSum > $max_value){
			$max_value = $thisSum;
			$end =$i;
		}else if($thisSum < 0){
			$thisSum = 0;
			$start= $i+1;
		}
	}
	return array($max_value,$start,$end);
}
//方法二、 记录上一次的结果  O(N^2)
function findMax2($data){
	$max_value = 0;
	$max_start = 0;
	$max_end = 0;
	$data_num = count($data);
	for($i=0;$i<$data_num;$i++){
		$last_sum = 0;
		for($j=$i;$j<$data_num;$j++){
			$sum = $last_sum+$data[$j];
			if($max_value < $sum){
				$max_value = $sum;
				$max_start = $i;
				$max_end = $j;
			}
			$last_sum = $sum;
		}
	}

	return array($max_value,$max_start,$max_end);
}


//冒泡排序时间复杂度为O(N^2)
function buddle_sort($arr){
	for($i=0;$i<count($arr);$i++){
		for($j=1;$j<$len-$i;$j++){
			if($arr[$j-1]>$arr[$i]){
				$temp = $arr[$j-1];
				$arr[$j-1] = $arr[$j];
				$arr[$j] = $temp;
			}
		}
	}
}




//快速排序时间复杂度 平均为O(nlogn)，最好为O(nlogn)，最差为O(logn2)
$a = array(2,13,42,34,56,23,67,365,87665,54,68,3);
function quick_sort($a){
	// 判断是否需要运行，因下面已拿出一个中间值，这里<=1
	if (count($a) <= 1) {
		return $a;
	}

	$middle = $a[0]; // 中间值

	$left = array(); // 接收小于中间值
	$right = array();// 接收大于中间值

	// 循环比较
	for ($i=1; $i < count($a); $i++) {

		if ($middle < $a[$i]) {

			// 大于中间值
			$right[] = $a[$i];
		} else {

			// 小于中间值
			$left[] = $a[$i];
		}
	}

	// 递归排序划分好的2边
	$left = quick_sort($left);
	$right = quick_sort($right);

	// 合并排序后的数据，别忘了合并中间值
	return array_merge($left, array($middle), $right);
}
print_r(quick_sort($a));
// 方案一，使用php来模拟这个过程这是著名的约瑟夫环问题
//一群猴子排成一圈，按1，2，...，n依次编号。然后从第1只开始数，数到第m只,把它踢出圈，
//从它后面再开始数，再数到第m只，在把它踢出去...，如此不停的进行下去，
//直到最后只剩下一只猴子为止，那只猴子就叫做大王。要求编程模拟此过程，输入m、n,输出最后那个大王的编号。
function king($n,$m){
	$mokey = range(1, $n);
	$i = 0;
	while (count($mokey) >1) {
		$i += 1;
		$head = array_shift($mokey);//一个个出列最前面的猴子
		if ($i % $m !=0) {
			#如果不是m的倍数，则把猴子返回尾部，否则就抛掉，也就是出列
			array_push($mokey,$head);
		}

		// 剩下的最后一个就是大王了
		return $mokey[0];
	}
}

//写一个二维数组排序算法函数，能够具有通用性，可以调用php内置函数
//二维数组排序，$arr是数据，$keys是排序的健值，$order是排序规则，1是降序，0是升序
function array_sort($arr,$keys,$order=0){
	if(!is_array($arr)){
		return false;
	}
	$keysvalue=array();
	foreach($arr as $key => $val){
		$keysvalue[$key] = $val[$keys];
	}
	if($order == 0){
		asort($keysvalue);
	}else{
		arsort($keysvalue);
	}
	reset($keysvalue);
	foreach($keysvalue as $key => $vals){
		$keysort[$key] = $key;
	}
	$new_array=array();
	foreach($keysort as $key=> $val){
		$new_array[$key]=$arr[$val];
	}
	return$new_array;
}
//测试
$person=array(
		array('id'=>2,'name'=>'zhangsan','age'=>23),
		array('id'=>5,'name'=>'lisi','age'=>28),
		array('id'=>3,'name'=>'apple','age'=>17)
);
$result = array_sort($person,'name',1);
print_r($result);

/*二分查找：前提，该数组已经是一个有序数组，必须先排序，再查找。*///O(h)=O(log2n)
function binarySearch(&$array,$findVal,$leftIndex,$rightIndex){
	$middleIndex=round(($rightIndex+$leftIndex)/2);
	if($leftIndex>$rightIndex){
		echo'查无此数<br/>';
		return;
	}
	if($findVal>$array[$middleIndex]){
		binarySearch($array,$findVal,$middleIndex+1,$rightIndex);
	}elseif($findVal<$array[$middleIndex]){
		binarySearch($array,$findVal,$leftIndex,$middleIndex-1);
	}else{
		echo"找到数据:index=$middleIndex;value=$array[$middleIndex]<br/>";
	}
}

//从0,1,2,3,4,5,6,7,8,9，这十个数字中任意选出三个不同的数字，“三个数字中不含0和5”的概率是7/15,C10 3,C9 2+C9 2-8   120-36-36-8

//一个三角形三个顶点有3只老鼠，一声枪响，3只老鼠开始沿三角形的边匀速运动，请问他们相遇的概率是
/**
 * 75%，每只老鼠都有顺时针、逆时钟两种运动方向，3只老鼠共有8种运动情况，只有当3只老鼠都为顺时针或者逆时钟，它们才不会相遇，剩余的6中情况都会相遇，故相遇的概率为6/8=75%。
 */
/**
 * MYSQL中主键与唯一索引的区别
 *  主键是一种约束，唯一索引是一种索引，两者在本质上是不同的
	主键创建后一定包含一个唯一性索引，唯一性索引并不一定就是主键
	唯一性索引列允许空值，而主键列不允许为空值
	主键列在创建时，已经默认为空值 + 唯一索引了
	主键可以被其他表引用为外键，而唯一索引不能
	一个表最多只能创建一个主键，但可以创建多个唯一索引
	主键更适合那些不容易更改的唯一标识，如自动递增列、身份证号等
	在 RBO 模式下，主键的执行计划优先级要高于唯一索引。 两者可以提高查询的速度
 */
/**
 * http与https的主要区别
 * 个基于OSI模型理解：
	http工作在应用层
	https是建立在SSL信道上的http，而SSL属于OSI模型中的传输层，所以我觉得HTTPS是属于传输层的协议
	但有同学提出了不同看法，相关讨论见：https://github.com/hookover/php-engineer-interview-questions/issues/7
	
	所以如果是基于TCP/IP模型的话：HTTP和SSL都是工作在应用层，那么HTTP和HTTPS同属应用层协议
	
	http是明文传输
	https是加密传输
	
	面试官会问到ssl数字证书,对称加密和非对称加密的区别
	
	超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息。HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息，比如信用卡号、密码等。
	为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS。为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。
	HTTPS和HTTP的区别主要为以下四点：
	一、https协议需要到ca申请证书，一般免费证书很少，需要交费。
	二、http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。
	三、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
	四、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
 */
/**
 * 
	200（成功）   服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果是对您的 robots.txt 文件显示此状态码，则表示 Googlebot 已成功检索到该文件。
	201（已创建） 请求成功并且服务器创建了新的资源。
	
	301（永久移动）请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。
    302（临时移动）服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。
    304（未修改）  自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。
    
    400（错误请求） 服务器不理解请求的语法。
    401（未授权）  请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。
	403（禁止）    服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码（您可以在 Google 网站管理员工具诊断下的网络抓取页面上看到此信息），可能是您的服务器或主机拒绝了 Googlebot 访问。
	404（未找到）  服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此代码。如果您的网站上没有 robots.txt 文件，而您在 Google 网站管理员工具“诊断”标签的 robots.txt 页上看到此状态码，则这是正确的状态码。但是，如果您有 robots.txt 文件而又看到此状态码，则说明您的 robots.txt 文件可能命名错误或位于错误的位置（该文件应当位于顶级域，名为 robots.txt）。
如果对于 Googlebot 抓取的网址看到此状态码（在”诊断”标签的 HTTP 错误页面上），则表示 Googlebot 跟随的可能是另一个页面的无效链接（是旧链接或输入有误的链接）。

	500（服务器内部错误）服务器遇到错误，无法完成请求。
	501（尚未实施）服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。
	502（错误网关）服务器作为网关或代理，从上游服务器收到无效响应。
	503（服务不可用）服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。
	504（网关超时）服务器作为网关或代理，但是没有及时从上游服务器收到请求。
	505（HTTP 版本不受支持）服务器不支持请求中所用的 HTTP 协议版本。
	
 */
/**
 *  linux中怎么查看系统资源占用情况,同时会问到怎么查看TCP端口,TCP连接状态 
  	top         //可能会问得更深,比如显示出来有哪些信息、你关心哪些信息、查看某个进程等
	iostat      //磁盘cpu
	free        //内存剩余
	df          //磁盘使用情况
	du          //文件占用信息
	
	ps              //查看进程信息
	netstat -anptol //查看端口占用情况,参数细节建议查文档,小心被问倒
 */
/**
 	SQL注入的原理是什么？如何防止SQL注入
	通常都是低级程序员写的低级代码,未过滤用户输入导致的,现代框架的ORM一般都做过相应处理,如果需要自己处理,有两种解决方式:
	1:转义用户输入(htmlentities/htmlspecialchars),用mysql_real_escape_string方法过滤SQL语句的参数
	2:预编译sql    (最佳方式)
 */

/**
 * 事务的特征：ACID
	原子性Atomicity 一组DML语句要么全部成功要么全部失败
	一致性Consistency 事务必须由一个状态到另一个状态
	隔离性Isolation 多个事务之间能够根据事务的隔离级别表现不同
	持久性Durability 提交后的事务，一旦提交，它对数据库中的数据修改是永久性的
Q:当没有事务的情况会出现什么问题?
A:当在控制台，操作mysql数据库时候，如果没有事务控制，误操作就会造成数据的永久损失。
事务的隔离级别:

隔离级别	脏读	不可重复读	幻读	加锁读?
读未提交(Read uncommitted)	o	o	o	不加锁
读已提交(Read committed)	x	o	o	不加锁
可重复读(Repeatable read)	x	x	o(mysql不会出现 x)	不加锁
可串行读(Serializable)	x	x	x	加锁 (全表锁)
脏读：当某个客户端查询出了另外一个事务还没有提交的修改数据，即为脏读。
不可重复读：[同一查询]在[同一事务]中多次进行，由其它提交事务所做的修改或删除，每次返回不同的的结果集，此时发生非重复读。
幻读：[同一查询]在[同一事务]中多次进行，由于其它提交事务(事务可能没提交)所做的插入操作，每次返回不同的结果集，此时发生幻读。
 */
/**
 * 写一个函数，尽可能高效的从一个标准URL中取出文件的扩展名
 * $ext = array_pop(explode('.',parse_url($url)['path']));
 */

/**
 *  echo    不是函数,没有返回值,仅用于打印信息,如果只是输出 echo 会更快
	print   有返回值,是函数,还能格式化输出
	print_r 则是打印复合类型如数组 对象
 */
/**TODO
 * 二叉树前中后遍历代码
 */
/**TODO
 * 25、PHP的数组和C语言的数组结构上有何区别？
 */
/**Redis中的有序集合是怎么实现的,它的数据结构是怎么样的TODO
 * https://www.cnblogs.com/paulversion/p/8194966.html
 */
/** 数组和hash表的区别是什么？
 *  数组是编程语言提供的一种数据类型，即用一组连续的内存空间来存放数据，可以通过一个首地址，和一个数组下标，直接访问这组内存空间中的任意位置。搜索
	哈希表是数据结构这门学科中的概念，是以数组为存储方式，实现的一种可以快速查找数据的数据结构。它是将数据的值通过一个映射函数，求出一个结果，然后把数据放在这个结果对应的数组下标的位置。搜索
 */
// 找出数组中不重复的值[1,2,3,3,2,1,5]
function uniqArray(){
	$res = [];
	foreach ($arr as $v){
		if(!empty($res)){
			if(in_array($v,$res)){
					
			}else {
					
			}	
		}else {
			$res [] = $v;
		}
		
	}
}





/**
 * 在HTTP通讯过程中，是客户端还是服务端主动断开连接？
	http1.1
	带content-length                       body长度可知     客户端主动断开
	带Transfer-encoding：chunked       body会被分成多个块，每块的开始会标识出当前块的长度，body就不需要通过content-length来指定了。但依然可以知道body的长度 客户端主动断开
	不带Transfer-encoding：chunked且不带content-length        客户端接收数据，直到服务端主动断开连接。
	即 ：如果能够有办法知道服务器传来的长度，都是客户端首先断开。如果不知道就一直接收数据。知道服务端断开。
 */

/**
 *  PHP中发起http请求有哪几种方式？它们有何区别？
	curl
	stream流的方式
	socket方式
 */

/**
 * 总结：如何实现一个通用的高性能的排序函数？
	一、如何选择合适的排序算法？
	1.排序算法一览表
	时间复杂度 是稳定排序？ 是原地排序？
	冒泡排序 O(n^2) 是 是
	插入排序 O(n^2) 是 是
	选择排序 O(n^2) 否 是
	快速排序 O(nlogn) 否 是 
	归并排序 O(nlogn) 是 否
	桶排序 O(n) 是 否
	计数排序 O(n+k)，k是数据范围 是 否
	基数排序 O(dn)，d是纬度 是 否
	2.为什选择快速排序？
	1）线性排序时间复杂度很低但使用场景特殊，如果要写一个通用排序函数，不能选择线性排序。
	2）为了兼顾任意规模数据的排序，一般会首选时间复杂度为O(nlogn)的排序算法来实现排序函数。
	3）同为O(nlogn)的快排和归并排序相比，归并排序不是原地排序算法，所以最优的选择是快排。
	二、如何优化快速排序？
	导致快排时间复杂度降为O(n)的原因是分区点选择不合理，最理想的分区点是：被分区点分开的两个分区中，数据的数量差不多。如何优化分区点的选择？有2种常用方法，如下：
	1.三数取中法
	①从区间的首、中、尾分别取一个数，然后比较大小，取中间值作为分区点。
	②如果要排序的数组比较大，那“三数取中”可能就不够用了，可能要“5数取中”或者“10数取中”。
	2.随机法：每次从要排序的区间中，随机选择一个元素作为分区点。
	3.警惕快排的递归发生堆栈溢出，有2中解决方法，如下：
	①限制递归深度，一旦递归超过了设置的阈值就停止递归。
	②在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈过程，这样就没有系统栈大小的限制。
	三、通用排序函数实现技巧
	1.数据量不大时，可以采取用时间换空间的思路
	2.数据量大时，优化快排分区点的选择
	3.防止堆栈溢出，可以选择在堆上手动模拟调用栈解决
	4.在排序区间中，当元素个数小于某个常数是，可以考虑使用O(n^2)级别的插入排序
	5.用哨兵简化代码，每次排序都减少一次判断，尽可能把性能优化到极致
 */

/**
 * 位移
 *  实例1：1<<4结果为16（对应二进制为00010000），相当于1*2^4=16；
	实例2：设一无符号短整型变量a=0111（对应二进制为0000000100010001），则a<<3结果为0888（对应二进制为0000100010001000）；a>>4结果为0011（0000000000010001）。

 */

/**
 * redis 数据类型
 * 	字符串： set name ;get name;
  
  	Hash（哈希）
	Redis hash 是一个键值(key=>value)对集合。
	Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。
	
	List（列表）
	Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。
	
	Set（集合）
	Redis的Set是string类型的无序集合。
	集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。
	
	zset(sorted set：有序集合)
	Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。
	不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。
	zset的成员是唯一的,但分数(score)却可以重复。
 * 
 */
/**
 * 事务的四个特性
 *  ⑴ 原子性（Atomicity）
　　原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。
	⑵ 一致性（Consistency）
　　一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。
　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。
	⑶ 隔离性（Isolation）
　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
　　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。
	⑷ 持久性（Durability）
　　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。
 */
















